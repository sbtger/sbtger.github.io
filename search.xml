<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>android_security</title>
    <url>/2020/07/15/android-security/</url>
    <content><![CDATA[<h1 id="Android-Security"><a href="#Android-Security" class="headerlink" title="Android Security"></a>Android Security</h1><hr>
<h2 id="1-Android基础知识"><a href="#1-Android基础知识" class="headerlink" title="1.Android基础知识"></a>1.Android基础知识</h2><hr>
<p>Android系统架构主要分为：应用层（java）、框架层（java）、库文件（C）&amp;Android运行时（运行java代码的虚拟机）和Linux kernel。</p>
<h3 id="Android四大组件："><a href="#Android四大组件：" class="headerlink" title="Android四大组件："></a>Android四大组件：</h3><p>Activity：窗口界面。Activity之间通过Intent进行通信。android应用的每一个Activity都必须在AndroidManifest.xml配置文件中声明。</p>
<p>Service：运行于后台，一般不需要与用户交互。一般为其他组件提供后台服务或监控其他组件的运行。有两种工作状态，一种是启动状态，主要用于执行后台计算；另一种是绑定状态，主要用于其他组件和service的交互。配置文件中需要声明全部service。</p>
<p>Content Provider：存放和获取数据并使这些数据可以被所有应用程序访问。应用程序间共享数据的唯一方法。</p>
<p>Broadcast Receiver：为了便于进行系统级别的消息推送。本质是一种全局的监听器，可以实现系统中不同组件之间的通信。发送广播用Intent，接收广播用广播接收器BroadcastReceiver。静态注册&amp;动态注册。</p>
<h3 id="Android安全机制："><a href="#Android安全机制：" class="headerlink" title="Android安全机制："></a>Android安全机制：</h3><p><strong>安全沙箱：</strong></p>
<p>Android每个应用程序都拥有唯一的UID和GID，每个应用是隔离的（文件/进程）。</p>
<p>数据目录：/data/data/。</p>
<p><strong>两个应用程序共享文件方法：</strong></p>
<p>（1）两个应用使用同样的证书签名，并在样式清单中使用相同shareUserId，可以互相访问彼此的数据目录。</p>
<p>（2）利用content provider，设置权限提供数据。</p>
<p><strong>权限控制：</strong></p>
<p>Normal级：申请后即可使用。</p>
<p>Dangerous级：在安装时由用户确认才可用。</p>
<p>Signature级：必须相同签名才能用。</p>
<p>Signatureorsystem：必须系统用户才可用。</p>
<h2 id="2-Android应用攻击面分析"><a href="#2-Android应用攻击面分析" class="headerlink" title="2.Android应用攻击面分析"></a>2.Android应用攻击面分析</h2><hr>
<h2 id="3-Android应用测试思路"><a href="#3-Android应用测试思路" class="headerlink" title="3.Android应用测试思路"></a>3.Android应用测试思路</h2><hr>
]]></content>
      <categories>
        <category>android security</category>
      </categories>
      <tags>
        <tag>android</tag>
        <tag>security</tag>
      </tags>
  </entry>
  <entry>
    <title>常用python代码</title>
    <url>/2020/07/13/python-code/</url>
    <content><![CDATA[<h1 id="常用python代码"><a href="#常用python代码" class="headerlink" title="常用python代码"></a>常用python代码</h1><hr>
<h2 id="1-numpy-array、torch-tensor和Image之间相互转换"><a href="#1-numpy-array、torch-tensor和Image之间相互转换" class="headerlink" title="1. numpy array、torch tensor和Image之间相互转换"></a>1. numpy array、torch tensor和Image之间相互转换</h2><h3 id="（1）numpy-array与Image之间互相转换"><a href="#（1）numpy-array与Image之间互相转换" class="headerlink" title="（1）numpy array与Image之间互相转换"></a>（1）numpy array与Image之间互相转换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image  </span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">im = Image.open(<span class="string">"a.jpg"</span>)</span><br><span class="line"></span><br><span class="line">img = np.array(im)      <span class="comment"># image to numpy array</span></span><br><span class="line">im=Image.fromarray(img) <span class="comment"># numpy array to image</span></span><br></pre></td></tr></table></figure>

<h3 id="（2）numpy-array与torch-tensor之间互相转换"><a href="#（2）numpy-array与torch-tensor之间互相转换" class="headerlink" title="（2）numpy array与torch tensor之间互相转换"></a>（2）numpy array与torch tensor之间互相转换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = torch.ones(<span class="number">5</span>)</span><br><span class="line">b = a.numpy()			<span class="comment"># torch tensor to numpy array</span></span><br><span class="line">a = torch.from_numpy(b)  <span class="comment"># numpy array to torch tensor</span></span><br><span class="line"><span class="comment"># 转换后的tensor与numpy array指向同一地址，对一方值的改变会改变另一方</span></span><br></pre></td></tr></table></figure>

<h3 id="（3）torch-tensor与Image之间互相转换"><a href="#（3）torch-tensor与Image之间互相转换" class="headerlink" title="（3）torch tensor与Image之间互相转换"></a>（3）torch tensor与Image之间互相转换</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"><span class="keyword">import</span> torch</span><br><span class="line"><span class="keyword">import</span> torchvision.transforms <span class="keyword">as</span> transforms</span><br><span class="line"></span><br><span class="line">path_img = <span class="string">"./1.bmp"</span></span><br><span class="line">img_pil = Image.open(path_img).convert(<span class="string">'RGB'</span>)</span><br><span class="line">img_tensor = transforms.Compose([</span><br><span class="line">    <span class="comment"># transforms.Resize((224, 224)),</span></span><br><span class="line">    transforms.ToTensor(),  <span class="comment"># Image to torch tensor</span></span><br><span class="line">    <span class="comment"># transforms.Normalize(norm_mean, norm_std),</span></span><br><span class="line">])(img_pil)</span><br><span class="line"></span><br><span class="line">img = transforms.ToPILImage()(img_tensor)</span><br><span class="line"><span class="comment"># torch tensor to Image</span></span><br></pre></td></tr></table></figure>

<hr>
<h2 id="2-numpy-array与list之间的转换"><a href="#2-numpy-array与list之间的转换" class="headerlink" title="2. numpy array与list之间的转换"></a>2. numpy array与list之间的转换</h2><figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = [[<span class="number">1.0</span>, <span class="number">2.0</span>], [<span class="number">2.0</span>, <span class="number">1.0</span>]] <span class="comment"># list a</span></span><br><span class="line">b = np.asarray(a) 			<span class="comment"># list to numpy array</span></span><br><span class="line">c = b.tolist()			    <span class="comment"># numpy array to list</span></span><br></pre></td></tr></table></figure>

<p><strong>numpy array与list的区别：</strong></p>
<p>存放的数据类型是否需要相同。numpy array存放的数据类型需要相同，list不需要相同。 </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">a = [<span class="string">'a'</span>,<span class="string">'b'</span>,<span class="string">'c'</span>,<span class="string">'1'</span>,<span class="string">'2'</span>,<span class="string">'3'</span>]</span><br><span class="line">b = np.array([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>])</span><br></pre></td></tr></table></figure>



<hr>
<h2 id="3-numpy的sum-函数"><a href="#3-numpy的sum-函数" class="headerlink" title="3. numpy的sum()函数"></a>3. numpy的sum()函数</h2><p>当sum()不传参数时，表示所有元素的总和。</p>
<p><strong>axis: 表示相加的不同维度。</strong></p>
<p>参数axis的值可以选取0、1和2，分别是从最外层向内层剥开计算，减少维度。</p>
<p>参数axis的值可以选取-3、-2和-1，分别是从最内层向外剥开开计算，减少维度。</p>
<p>如下图，numpy的sum()函数使用实例。</p>
<p><img src="/2020/07/13/python-code/1.PNG" alt="image 1"></p>
<p><strong>keepdims: 表示是否保持矩阵二维特性。</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line">array([[<span class="number">1</span>],[<span class="number">2</span>]])</span><br><span class="line">array([<span class="number">1</span>,<span class="number">2</span>])</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="4-np-linalg-norm-函数"><a href="#4-np-linalg-norm-函数" class="headerlink" title="4. np.linalg.norm()函数"></a>4. np.linalg.norm()函数</h2><p><strong>linalg = linear + algebra 线性代数</strong> </p>
<p><strong>norm 范数</strong></p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line">x_norm = np.linalg.norm(x, ord=<span class="literal">None</span>, axis=<span class="literal">None</span>, Keepdims=<span class="literal">False</span>)</span><br></pre></td></tr></table></figure>

<p><strong>x: 表示输入数据。可以为向量或者矩阵。</strong></p>
<p><strong>ord: 表示范数类型。</strong></p>
<table>
<thead>
<tr>
<th align="center">ord</th>
<th align="center">范数类型</th>
<th align="center">计算公式</th>
</tr>
</thead>
<tbody><tr>
<td align="center">None</td>
<td align="center">二范数（默认）</td>
<td align="center">$\sqrt{x_1^2+x_2^2+…+x_n^2}$</td>
</tr>
<tr>
<td align="center">1</td>
<td align="center">一范数</td>
<td align="center">$|x_1|+|x_2|+…+|x_n|$</td>
</tr>
<tr>
<td align="center">2</td>
<td align="center">二范数</td>
<td align="center">$\sqrt{x_1^2+x_2^2+…+x_2^2}$</td>
</tr>
<tr>
<td align="center">np.inf</td>
<td align="center">无穷范数</td>
<td align="center">$max(|x_i|)$</td>
</tr>
</tbody></table>
<p><strong>axis: 表示从不同维度处理。</strong></p>
<p><strong>keepdims: 表示是否保持矩阵二维特性。</strong></p>
<hr>
]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
        <tag>numpy</tag>
        <tag>PIL</tag>
        <tag>torch</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言程序设计笔记_存储器寻址</title>
    <url>/2020/03/25/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0_%E5%AD%98%E5%82%A8%E5%99%A8%E5%AF%BB%E5%9D%80/</url>
    <content><![CDATA[<h2 id="更灵活的定位内存地址的方法"><a href="#更灵活的定位内存地址的方法" class="headerlink" title="更灵活的定位内存地址的方法"></a>更灵活的定位内存地址的方法</h2><h3 id="and和or指令"><a href="#and和or指令" class="headerlink" title="and和or指令"></a>and和or指令</h3><p>and指令可将操作对象的相应位设为0，其他位不变。</p>
<p>or指令可将操作对象的相应位设为1，其他位不变。</p>
<h3 id="ASCII-码"><a href="#ASCII-码" class="headerlink" title="ASCII 码"></a>ASCII 码</h3><p>一种编码方案。字符存储在计算机中的是ASCII码转换的二进制。</p>
<h3 id="大小写转换的问题"><a href="#大小写转换的问题" class="headerlink" title="大小写转换的问题"></a>大小写转换的问题</h3><p>‘A’ ASCII 41H ‘a’ ASCII 61H 小写比大写ASCII码大20H。</p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式系统安全笔记_接口技术</title>
    <url>/2020/03/24/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0-%E6%8E%A5%E5%8F%A3%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<h2 id="嵌入式接口技术——通信"><a href="#嵌入式接口技术——通信" class="headerlink" title="嵌入式接口技术——通信"></a>嵌入式接口技术——通信</h2><p>找例程编译。学会修改例程，提高可靠性。</p>
<p><strong>硬件：</strong>通信（相互通道）、输入（前向通道）、输出（后向通道）</p>
<p><strong>部件：</strong>传感器、执行器、人机界面、相互通信、电源</p>
<a id="more"></a>

<p>硬件-通信（相互通道）外围部件的扩展是利用这些通道进行的。</p>
<p><strong>串行通信UART：</strong>在一根通信线上传输数据信息与联络信息。区分这2类信息的约定即通信协议。</p>
<ul>
<li>单工通信</li>
<li>半双工通信</li>
<li>全双工通信</li>
</ul>
<p>串行通信方式：异步通信与同步通信（需要时钟）</p>
<p>异步协议一般用在数据速率较低的场合。高速传输时，一般采用同步协议。</p>
<p>异步通信是按字符帧传输：1个起始位（‘0’）、5-8个数据位、1个奇偶校验位（不一定需要）与1-2个停止位（‘1’）。</p>
<p><strong>停止位：</strong>接收方的保护时间，使接收方有足够的时间处理收到的数据。</p>
<p>异步通信对字符的格式、波特率、校验位有确定的要求。</p>
<p>异步串行通信性能：发送和接收缓冲器的数量。</p>
<p>发送时检查：发送缓冲区是否满；移位寄存器有没有发送完。</p>
<p>常见错误：奇偶校验错；帧出错；溢出错（接收字符未读，后续字符则覆盖）。</p>
<p><strong>RS-232C：</strong>点对点的。</p>
<p>串行接口标准：把0和1的距离拉开，为了传得更远。</p>
<p>逻辑1=-3<del>-15V 逻辑0=+3</del>+15V （反向放大）数据发送与接收</p>
<p>信号有效+3<del>+15V  信号无效-3</del>-15V 控制与状态信号</p>
<p>TTL与EIA-RS-232C转换：</p>
<p>利用MC1488/1489来连接TTL与RS-232C，且外接电源。</p>
<p>现在是MAX232转换，按电源（5V与3.3V）或电容分类（电解电容、瓷片电容、无电容）。</p>
<p>RS-232C易损坏接口电路的芯片。</p>
<p><strong>RS-485：</strong>多对多的。</p>
<p>逻辑“1” +2<del>+6V 逻辑“0” -2</del>-6V 不易损坏接口芯片。</p>
<p>有抑制共模干扰的能力。为了传输更长的距离，需要加485中继器，可加多个节点。工程上是分组的处理。</p>
<p>注意事项：极性、最远端端匹配电阻、T型线长度、线路保护。</p>
<p><strong>串行通信协议应用注意事项：</strong></p>
<ul>
<li>接收与死机（<strong>超时处理、重新初始化、接收缓冲区防溢出</strong>）</li>
<li>停止位（<strong>又叫数据保护时间</strong>，1.5个二进制位的时间）位数与可靠通信（有效通信速率、保障接收方的数据处理时间）</li>
<li>波特率精度（<strong>±2.5%，外置振荡器、配置选择与通信精度</strong>）与可靠通信</li>
<li>通信协议、帧格式、收发切换时间及校验</li>
<li>帧间隔（<strong>字符帧、通信协议帧</strong>）、帧长度</li>
<li>波特率与通信距离</li>
</ul>
<p><strong>I2C总线：</strong>简单与有效。</p>
<p>数据线SDA与时钟线SCL。两根信号线必须OC并接上拉电阻。各种设备均并联在这条总线上，每个设备都有唯一的地址。</p>
<p>可以有多次启动信号。终止信号P最高级别的中断。</p>
<p>SPI</p>
<p>1-WRIE(单总线)</p>
]]></content>
      <categories>
        <category>嵌入式系统安全</category>
      </categories>
      <tags>
        <tag>嵌入式系统安全</tag>
        <tag>接口</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全笔记_缓冲区溢出</title>
    <url>/2020/03/23/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0_%E7%BC%93%E5%86%B2%E5%8C%BA%E6%BA%A2%E5%87%BA/</url>
    <content><![CDATA[<h2 id="缓冲区溢出"><a href="#缓冲区溢出" class="headerlink" title="缓冲区溢出"></a>缓冲区溢出</h2><h3 id="缓冲区溢出攻击的原理"><a href="#缓冲区溢出攻击的原理" class="headerlink" title="缓冲区溢出攻击的原理"></a>缓冲区溢出攻击的原理</h3><h4 id="1、缓冲区溢出攻击模式："><a href="#1、缓冲区溢出攻击模式：" class="headerlink" title="1、缓冲区溢出攻击模式："></a>1、缓冲区溢出攻击模式：</h4><ul>
<li>找到可利用的缓冲区溢出隐患</li>
<li>注入恶意代码</li>
<li>溢出缓冲区</li>
<li>重定向到攻击程序</li>
<li>执行攻击程序</li>
<li>获得控制权</li>
<li>任意地执行程序</li>
</ul>
<a id="more"></a>

<h4 id="2、进程在内存的布局："><a href="#2、进程在内存的布局：" class="headerlink" title="2、进程在内存的布局："></a>2、进程在内存的布局：</h4><p><strong>代码段/文本段：</strong>用于放置程序的可执行代码（机器码）。</p>
<p><strong>数据段：</strong>用于放置<strong>已初始化</strong>的全局变量和已初始化的局部静态变量。 已初始化且不为0。</p>
<p><strong>BSS(Block Started by Symbol)段：</strong>用于放置<strong>未初始化</strong>的全局变量和未初始化的局部静态变量。</p>
<p><strong>堆：</strong>用于动态分配内存。</p>
<p><strong>堆栈段：</strong>用于存放函数的参数，返回地址，调用函数的栈基址以及局部非静态变量。</p>
<p><strong>进程的环境变量和参数</strong></p>
<p>缓冲区溢出可能发生的位置：栈、堆、数据段和BSS段。</p>
<h4 id="3、被调函数栈布局："><a href="#3、被调函数栈布局：" class="headerlink" title="3、被调函数栈布局："></a>3、被调函数栈布局：</h4><p>函数调用堆栈的操作：</p>
<p><strong>main栈帧：</strong></p>
<ul>
<li><strong>参数</strong>入栈，一般从右到左压栈。push</li>
<li><strong>返回地址</strong>的压栈。call function（返回地址压栈；跳转到function）。</li>
</ul>
<p><strong>function栈帧：</strong></p>
<ul>
<li><strong>push ebp</strong></li>
<li>被调函数的<strong>局部变量</strong>分配内存空间。</li>
<li>函数体<strong>执行</strong>。</li>
<li>执行完成，<strong>ret</strong>。</li>
</ul>
<p><strong>潜在危害：</strong></p>
<ul>
<li>改写返回地址</li>
<li>改写调用函数栈的栈帧地址</li>
<li>改写函数指针</li>
<li>改写虚函数指针</li>
<li>改写异常处理指针</li>
<li>改写数据指针</li>
</ul>
<h4 id="4、缓冲区溢出的途径："><a href="#4、缓冲区溢出的途径：" class="headerlink" title="4、缓冲区溢出的途径："></a>4、缓冲区溢出的途径：</h4><ul>
<li>内存拷贝。</li>
<li>利用数组的最大下标和数组长度的差异产生。</li>
<li>利用有符号整数与无符号整数的转换。</li>
<li>恶意代码（注入）。exec(/bin/sh)</li>
</ul>
]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>缓冲区溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>checksec</title>
    <url>/2020/03/22/checksec/</url>
    <content><![CDATA[<h2 id="checksec"><a href="#checksec" class="headerlink" title="checksec"></a>checksec</h2><p>Checksec.sh是一个bash脚本，用于检查一些可执行的属性，例如（PIE，RELRO，PaX，Canaries，ASLR，Fortify Source）。它最初是由Tobias Klein编写的，其原始资源可以在这里找到：<a href="http://www.trapkit.de/tools/checksec.html" target="_blank" rel="noopener">checksec</a>。</p>
<a id="more"></a>

<p><img src="/2020/03/22/checksec/1.PNG" alt="1"></p>
<ul>
<li><p><strong>PIE：</strong>地址随机化。如果程序开启了地址随机化选项（PIE enabled），意味着程序每次运行地址都会变化。如果程序没有开启地址随机化选项（No PIE），则程序的基地址为 (0x400000)。</p>
</li>
<li><p><strong>RELRO：</strong>RELRO有Partial RELRO和FULL RELRO。如果开启FULL RELRO，意味着我们无法修改GOT表。</p>
</li>
<li><p><strong>Stack：</strong>金丝雀机制。如果栈中开启Canary机制（Canary found），那么就不能直接用溢出的方法覆盖栈中返回地址，而且要通过改写指针与局部变量、leak canary、overwrite canary等方法来绕过。</p>
</li>
<li><p><strong>NX：</strong>栈不可执行。如果开启NX保护，则栈中数据没有执行权限。call esp或jmp esp的方法无法使用，但可以利用rop的方法绕过。</p>
</li>
<li><p><strong>FORTIFY：</strong>格式化字符串保护。FORTIFY_SOURCE机制对格式化字符串有两个限制：（1）包含%n的格式化字符串不能位于程序内存中的可写地址。（2）当使用位置参数时，必须使用范围内的所有参数。所以如果要使用%7$x，你必须同时使用参数1、2、3、4、5和6。</p>
</li>
</ul>
<h2 id="Linux常见的保护机制"><a href="#Linux常见的保护机制" class="headerlink" title="Linux常见的保护机制"></a>Linux常见的保护机制</h2><h3 id="1-NX（Windows中的DEP）"><a href="#1-NX（Windows中的DEP）" class="headerlink" title="1. NX（Windows中的DEP）"></a>1. NX（Windows中的DEP）</h3><p><strong>NX：</strong>No-eXecute</p>
<p><strong>DEP：</strong>Data Execute Prevention</p>
<p>数据不可执行。<br>gcc编译选项（默认开启与关闭NX）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c</span><br><span class="line">gcc -z execstack -o <span class="built_in">test</span> test.c</span><br></pre></td></tr></table></figure>

<h3 id="2-PIE（ASLR）"><a href="#2-PIE（ASLR）" class="headerlink" title="2. PIE（ASLR）"></a>2. PIE（ASLR）</h3><p> <strong>PIE</strong>：Position-Independent Excutable</p>
<p><strong>ASLR</strong>：Address Space Layout Randomization</p>
<p> 开启PIE选项编译可执行文件，可以使得elf文件拥有共享库属性。ASLR负责栈、库、堆等段的地址随机化。<br>关闭ASLR的bash命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo sh -c <span class="string">"echo 0 &gt; /proc/sys/kernel/randomize_va_space"</span></span><br></pre></td></tr></table></figure>

<h3 id="3-Canary（栈保护）"><a href="#3-Canary（栈保护）" class="headerlink" title="3. Canary（栈保护）"></a>3. Canary（栈保护）</h3><p> 金丝雀（Canary）机制：函数每一次执行时，在栈上随机产生一个置于缓冲区和控制数据之间的Canary值。之后当函数执行结束返回时，检测Canary值，若不一致系统则报出异常。例如当发生缓冲区溢出时，该值则会被覆写。<br>gcc编译选项（默认关闭、禁用与启用栈保护）：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -o <span class="built_in">test</span> test.c</span><br><span class="line">gcc -fno-stack-protector -o <span class="built_in">test</span> test.c</span><br><span class="line">gcc -fstack-protector-all -o <span class="built_in">test</span> test.c</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>主流操作系统安全_Windows</title>
    <url>/2020/03/20/%E4%B8%BB%E6%B5%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8_Windows/</url>
    <content><![CDATA[<h2 id="Winodws系统结构"><a href="#Winodws系统结构" class="headerlink" title="Winodws系统结构"></a>Winodws系统结构</h2><h3 id="Windows引导过程："><a href="#Windows引导过程：" class="headerlink" title="Windows引导过程："></a>Windows引导过程：</h3><ul>
<li>BIOS</li>
<li>MBR</li>
<li>引导扇区（引导分区的第一个扇区）</li>
<li>引导扇区后续扇区</li>
<li>ntldr(实模式部分)：切换至保护模式</li>
<li>ntldr(保护模式部分：os loader)</li>
</ul>
<a id="more"></a>

<p><strong>ntldr的工作：</strong></p>
<p>构造内存描述符数组；映射页面，设置页目录寄存器，打开内存页面映射机制；处理boot.ini；执行ntdetect.com；加载内核模块ntoskrnl.exe、hal.dll和SYSTEM储巢；加载引导驱动程序和必要的文件系统驱动程序；构造LOADER_PARAMETER_BLOCK参数块；将控制交给内核模块ntoskrnl.exe的入口函数</p>
<h3 id="内核初始化："><a href="#内核初始化：" class="headerlink" title="内核初始化："></a>内核初始化：</h3><ul>
<li>0阶段初始化：在进程中进行。初始化CPU和一部分kernel的数据机构。</li>
<li>1阶段初始化：在线程中进行，可并发。初始化绝大多数的模块。</li>
</ul>
<h2 id="操作系统内核与驱动开发"><a href="#操作系统内核与驱动开发" class="headerlink" title="操作系统内核与驱动开发"></a>操作系统内核与驱动开发</h2><h3 id="内核与驱动的关系"><a href="#内核与驱动的关系" class="headerlink" title="内核与驱动的关系"></a>内核与驱动的关系</h3><p><strong>功能</strong>角度，驱动在内核的下层。硬件=&gt;驱动=&gt;内核=&gt;应用。<strong>代码</strong>角度，驱动和内核开发实际融为一体。</p>
<p>驱动开发需要考虑<strong>问题</strong>：同步异步/共享独占/缓冲区管理/设备状态管理。</p>
<p>驱动属于IO系统的一部分，向下是HAL或硬件。</p>
<h3 id="驱动开发"><a href="#驱动开发" class="headerlink" title="驱动开发"></a>驱动开发</h3><p><strong>什么是驱动程序？</strong></p>
<p><strong>驱动程序</strong>是一个<strong>软件</strong>组件，可让<strong>操作系统</strong>和<strong>设备</strong>彼此通信。 例如，假设<strong>应用程序</strong>需要从<strong>设备</strong>中读取某些<strong>数据</strong>。 应用程序会调用由<strong>操作系统</strong>实现的函数，操作系统会调用由<strong>驱动程序</strong>实现的函数。</p>
<p>并非所有驱动程序都直接与设备通信。堆栈中直接与设备通信的一个驱动程序称为“<strong>函数驱动程序</strong>” ；执行辅助处理的驱动程序称为“<strong>筛选器驱动程序</strong>” 。</p>
<p><strong>软件驱动程序：</strong>未与设备关联的驱动程序 。可以访问核心操作系统数据结构。</p>
<p><strong>扩展定义：</strong>驱动程序是观察或参与操作系统和设备之间通信的任何软件组件。</p>
<p><strong>Windows驱动开发模型：</strong></p>
<p><strong>DDK</strong>(Driver Developer Kit)=&gt;<strong>WDK</strong>(Windows Driver Kit)</p>
<p>操作系统与驱动程序之间遵循<strong>容器</strong>与<strong>插件</strong>模型。Driver是一种<strong>被动</strong>的软件模块。驱动程序是一个<strong>回调函数</strong>的集合体，类似于DLL程序。</p>
<p>驱动程序可以调用<strong>Windows内核API</strong>、WDK运行时间库和其他驱动程序。不能调用用户模式API和ISO规定的C/C++标准函数库。</p>
<p><strong>驱动对象与设备对象：</strong></p>
<p>一个驱动对象下可能有多个设备对象，一个设备对象只能对应一个驱动对象。</p>
<p><strong>IRP(I/O Request Package)：</strong></p>
<p>上层应用程序与下层设备进行IO时，利用IRP进行通信。</p>
<p><img src="/2020/03/20/%E4%B8%BB%E6%B5%81%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8_Windows/1.png" alt="1"></p>
]]></content>
      <categories>
        <category>主流操作系统安全</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
        <tag>Windows</tag>
        <tag>驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>信息采集_爬虫</title>
    <url>/2020/03/20/%E4%BF%A1%E6%81%AF%E9%87%87%E9%9B%86_%E7%88%AC%E8%99%AB/</url>
    <content><![CDATA[<h2 id="Scrapy框架："><a href="#Scrapy框架：" class="headerlink" title="Scrapy框架："></a>Scrapy框架：</h2><p>安装Scrapy需要安装lxml、Twisted、scrapy和pypiwin32包。只需要pip install 对应包即可安装。</p>
<a id="more"></a>

<p><strong>如何查找与本机符合的whl文件的版本？</strong></p>
<p>有些时候，我们需要利用whl文件安装python的包。whl文件本质上是一个压缩包，里面包含了py文件和经过编译的pyd文件。使得可以在不具备编译环境的情况下进行安装。</p>
<p>利用pip工具取查询本机对应的安装标签，在命令行中打开python，输入如下代码，即可得到对应安装的标签（如cp37-cp37m-win_amd64）。</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pip._internal.pep425tags</span><br><span class="line">print(pip._internal.pep425tags.get_supported())</span><br></pre></td></tr></table></figure>

<p>如果是32位系统，则输入如下指令</p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> pip.pep425tags</span><br><span class="line">print(pip.pep425tags.get_supported())</span><br></pre></td></tr></table></figure>









]]></content>
      <categories>
        <category>信息内容安全</category>
      </categories>
      <tags>
        <tag>信息内容安全</tag>
        <tag>爬虫</tag>
        <tag>信息采集</tag>
        <tag>Scrapy</tag>
      </tags>
  </entry>
  <entry>
    <title>微机接口笔记_存储器</title>
    <url>/2020/03/19/%E5%BE%AE%E6%9C%BA%E6%8E%A5%E5%8F%A3%E7%AC%94%E8%AE%B0_%E5%AD%98%E5%82%A8%E5%99%A8/</url>
    <content><![CDATA[<h2 id="存储器与CPU的连接"><a href="#存储器与CPU的连接" class="headerlink" title="存储器与CPU的连接"></a>存储器与CPU的连接</h2><h3 id="1-设计接口应考虑的问题"><a href="#1-设计接口应考虑的问题" class="headerlink" title="1. 设计接口应考虑的问题"></a>1. 设计接口应考虑的问题</h3><ul>
<li>CPU总线的负载能力：总线直接驱动负载能力超过后，应在总线和负载间接缓冲器或驱动器，否则会影响信号逻辑电平。</li>
<li>CPU时序与存储器存取速度间的配合</li>
<li>存储器的地址分配和片选</li>
<li>控制信号的连接</li>
</ul>
<a id="more"></a>

<h3 id="2-存储器接口设计"><a href="#2-存储器接口设计" class="headerlink" title="2. 存储器接口设计"></a>2. 存储器接口设计</h3><h4 id="地址译码器："><a href="#地址译码器：" class="headerlink" title="地址译码器："></a>地址译码器：</h4><p><strong>片选操作。</strong>  74LS138译码器是常用的8取1的译码器。</p>
<p><strong>38译码器功能：</strong>（1）根据片选输入选择对应芯片进行I/O访问。（2）通过38译码器控制存储器的工作。</p>
<h4 id="存储空间的扩展："><a href="#存储空间的扩展：" class="headerlink" title="存储空间的扩展："></a>存储空间的扩展：</h4><p><strong>位扩展：</strong>芯片层叠。</p>
<p><strong>字扩展：</strong>芯片并排。</p>
<p><strong>字位扩展：</strong>芯片层叠加并排。先考虑位扩展再考虑字扩展。</p>
<h4 id="形成片选信号的三种方法："><a href="#形成片选信号的三种方法：" class="headerlink" title="形成片选信号的三种方法："></a>形成片选信号的三种方法：</h4><p><strong>线选法：</strong>线路简单，但空间浪费、地址重叠、地址不连续。</p>
<p><strong>全译码：</strong>全部高位地址都参与译码。没有用到的地址信号可以固定到译码器上。</p>
<p><strong>部分译码：</strong>只对高位地址中的某几位译码，生成片选信号。如果有高位地址没有使用，则会出现地址重叠。</p>
]]></content>
      <categories>
        <category>微机接口</category>
      </categories>
      <tags>
        <tag>微机接口</tag>
        <tag>存储器</tag>
      </tags>
  </entry>
  <entry>
    <title>汇编语言程序设计笔记_Loop</title>
    <url>/2020/03/18/%E6%B1%87%E7%BC%96%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E7%AC%94%E8%AE%B0_Loop/</url>
    <content><![CDATA[<h2 id="bx-和Loop指令"><a href="#bx-和Loop指令" class="headerlink" title="[bx]和Loop指令"></a>[bx]和Loop指令</h2><p>[bx]是什么？实际指代内存单元中的内容。基址默认是ds中。内存单元大小可以通过上下文判断。</p>
<p>push ax：(sp)=(sp)-2 ((ss)*16+(sp))=ax</p>
<p>pop ax：(ax)=((ss)*16+(sp)) (sp)=(sp)+2</p>
<a id="more"></a>

<h3 id="Loop指令："><a href="#Loop指令：" class="headerlink" title="Loop指令："></a>Loop指令：</h3><p><strong>执行步骤：</strong></p>
<ul>
<li>(cx)=(cx)-1</li>
<li>判断cx中的值，不为0则转至标号处执行程序，如果为0则向下执行。</li>
</ul>
<p><strong>要点：</strong></p>
<ul>
<li>(cx)为实际执行循环次数。</li>
<li>loop指令中的标号所标识的地址要在前面。</li>
<li>要循环执行的程序段，要写在标号和loop指令之间。</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">assume cs:code</span><br><span class="line">code segment</span><br><span class="line">	mov bx,0</span><br><span class="line">	mov cx,12</span><br><span class="line">    mov ax,0ffffh</span><br><span class="line">    mov ds,ax</span><br><span class="line">    mov ax,0020h</span><br><span class="line">    mov es,ax</span><br><span class="line"> s: mov al,[bx]</span><br><span class="line">    mov es:[bx],al</span><br><span class="line">    inc bx</span><br><span class="line">    loop s</span><br><span class="line">    </span><br><span class="line">	mov ax,4c00h</span><br><span class="line">	int 21h</span><br><span class="line">code ends</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p><strong>汇编编译器的小问题</strong>：</p>
<p>汇编编译器中，数据不能以字母开头，所以FFFFH需要改为0FFFFH。</p>
<p>有些汇编编译器不能识别[数字]，故一般使用[bx].</p>
<p><strong>Loop和[bx]的联合使用：</strong></p>
<p>为了类型的匹配和结果的不超界，可以使用Loop和[bx]联合的方法。</p>
<p><strong>一段安全的内存空间：</strong></p>
<p>DOS和其他合法程序一般都不会使用<strong>0:200~0:2ff</strong>的256个字节的空间。</p>
]]></content>
      <categories>
        <category>汇编语言</category>
      </categories>
      <tags>
        <tag>汇编语言</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式系统安全笔记_ARM</title>
    <url>/2020/03/17/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0_ARM/</url>
    <content><![CDATA[<h2 id="PIC"><a href="#PIC" class="headerlink" title="PIC"></a>PIC</h2><h3 id="中断："><a href="#中断：" class="headerlink" title="中断："></a>中断：</h3><ul>
<li><p>中断分组管理（快速中断屏蔽）与控制</p>
</li>
<li><p>统一中断入口：根据中断标志位判断中断的类型。<strong>因为中断标志位始终会产生，所以开放中断前需要清除中断标志位。</strong></p>
</li>
<li><p>边沿触发：外部中断可以边沿选择。数字信号低电平的驱动能力比较强，下降沿（更陡峭），下降时间比较短，故从可靠性的角度下降沿触发最佳。</p>
</li>
<li><p>电平变化中断：端口处有异或比较器，当变化时产生中断，从而识别边沿。</p>
</li>
</ul>
<a id="more"></a>

<h3 id="低压差稳压器（LDO）："><a href="#低压差稳压器（LDO）：" class="headerlink" title="低压差稳压器（LDO）："></a>低压差稳压器（LDO）：</h3><p>为了支持PIC芯片的普适性，内部使用type B（降低功耗），端口使用type A（提高可靠性）。</p>
<h3 id="芯片配置字："><a href="#芯片配置字：" class="headerlink" title="芯片配置字："></a>芯片配置字：</h3><p>芯片的某些引脚或硬件需要在芯片工作之前就进行配置，硬件实现。配置字中有关于复位、振荡器的规划。</p>
<h3 id="PIC端口结构："><a href="#PIC端口结构：" class="headerlink" title="PIC端口结构："></a>PIC端口结构：</h3><p>与80C51相比，引进了钳位二极管、模数选择、方向选择、上拉电阻选择.</p>
<h3 id="PIC振荡器："><a href="#PIC振荡器：" class="headerlink" title="PIC振荡器："></a>PIC振荡器：</h3><p>PIC存在内部振荡器，可以通过外部校准内部。可以控制振荡器。在响应速度、功耗和抗干扰能力三者中达到平衡。</p>
<h3 id="PIC与80C51总体比较："><a href="#PIC与80C51总体比较：" class="headerlink" title="PIC与80C51总体比较："></a>PIC与80C51总体比较：</h3><p>普适性提高，但配置比较复杂，易用性降低。</p>
<h3 id="几个关键概念："><a href="#几个关键概念：" class="headerlink" title="几个关键概念："></a>几个关键概念：</h3><p><strong>电源电压：</strong>三类（A=5V, B=3.3V, C=1.8V）。</p>
<p><strong>通用端口电平要求：</strong>H≥70%Vcc L≤30%Vcc。</p>
<p><strong>复位电平要求：</strong>H≥80%Vcc L≤12%Vcc。</p>
<p><strong>信号上升时间：</strong>10%Vcc上升到90%VCC所需要的时间。</p>
<p><strong>信号下降时间：</strong>90%Vcc下降到10%VCC所需要的时间。</p>
<p>信号上升时间一般比信号下降时间长。好的信号要求信号上升时间与下降时间≤信号周期*4%。可以通过降低频率（周期变长）来实现。</p>
<p><strong>功耗控制：</strong>P=K*F，分部件控制时钟（降低功耗且躲避干扰）。</p>
<p><strong>看门狗与可靠性：</strong>硬件看门狗发现软件的问题，产生复位。错误不可避免。每种复位不同，因此便于软件处理，恢复到之前状态。</p>
<p><strong>推挽输出与OC（OD）输出：</strong>频率高，更有利于提高速度。内部推挽输出OC，板外输出一般为OD。</p>
<h2 id="ARM架构"><a href="#ARM架构" class="headerlink" title="ARM架构"></a>ARM架构</h2><h3 id="1-ARM-体系结构"><a href="#1-ARM-体系结构" class="headerlink" title="1. ARM 体系结构"></a>1. ARM 体系结构</h3><p><strong>ARM系列微处理器扩展命名扩展符号：</strong></p>
<p><strong>T</strong> 16位<strong>Thumb</strong>指令集：硬件扩展为ARM指令集，因此为压缩指令集，不占用芯片运行的时间。</p>
<p>版本：ARMv4T、 ARMv5T和ARMv6T。</p>
<p>代码尺寸：Thumb指令编译其长度只占ARM指令的<strong>65%</strong>左右。带来<strong>功耗</strong>上的优势。但<strong>时间</strong>上会差一些，增加了指令解压以及需要比ARM更多的指令执行。在异常中断的低级处理时，还是需要使用ARM指令。如果主导因素是<strong>空间</strong>则选择<strong>Thumb</strong>，<strong>性能</strong>则ARM与Thumb指令集2者的平衡。</p>
<p><strong>D</strong> 片上调试 <strong>debug</strong>：响应调试强求暂停</p>
<p><strong>M</strong> 支持增强型<strong>乘法器</strong>：<strong>32位</strong>乘<strong>32位</strong>得到<strong>64位</strong>。ARMV4版本以后，M变种已为标准配置。增加2条AKM指令：长乘法操作和长乘加操作。有时有乘法没除法。</p>
<p><strong>I</strong> 嵌入式<strong>ICE</strong>部件：提供<strong>断点</strong>和<strong>调试点</strong>。</p>
<p><strong>E</strong> 增强DSP指令：（1）增加<strong>16位</strong>乘法和乘加。（2）<strong>实现饱和的带符号数的加减法操作的指令。</strong>溢出时，<strong>使用最大或最小值</strong>。因此代码不需要判断溢出。</p>
<p><strong>J</strong> <strong>Java</strong>加速器Jazelle：提高Java代码的运行速度，最高可达到<strong>8倍</strong>，功耗降低<strong>80%</strong>。</p>
<p><strong>S</strong> 可综合：提供VHDL或Verilog HDL硬件描述语言设计文件。</p>
<p><strong>ARM架构的版本：</strong></p>
<p>更新：（1）不断创新提升性能（2）向下兼容保护软件投入</p>
<ul>
<li>ARMv4T架构：每条指令1.5个时钟周期。</li>
<li>ARMv6架构：Thumb-2指令集。</li>
<li>ARMv7架构：A系列（支持大型嵌入式操作系统）、R系列（实时性）和M系列（单片机/MCU，追求低成本低功耗）。</li>
<li>ARM Cortex系列，全部采用ARMv7架构。</li>
</ul>
<p><strong>三种总线：</strong></p>
<p>ARM的总线体系结构是AMBA。存在对总线的控制。</p>
<ul>
<li><p><strong>AHB：</strong>连接<strong>高性能</strong>系统模块。支持突发数据传输（例如DMA）。支持单个数据传输。支持分离式总线事务处理。</p>
</li>
<li><p><strong>ASB：</strong>连接<strong>高性能</strong>系统模块。支持突发数据传输。</p>
</li>
<li><p><strong>APB：</strong>简单接口。支持<strong>低性能</strong>外围接口。</p>
</li>
</ul>
<p><strong>ARM工作模式：</strong></p>
<p>用户模式（usr）、快速中断模式（fiq）、外部中断模式（irq）、管理模式（svc）、指令/数据访问终止模式（abt）、系统模式（sys）和未定义指令终止模式（und）。</p>
<p>工作模式可通过<strong>软件</strong>控制改变，也可通过<strong>外部</strong>中断或异常处理改变。</p>
<p>程序代码角度：ARM状态和Thumb状态。</p>
<p>ARM处理器核在上电或复位并开始执行程序代码时，处于ARM状态。利用指令<strong>CODE 16/32</strong>进行切换。</p>
<p><strong>内部寄存器：</strong></p>
<p>37个32位寄存器，分为通用寄存器（31）和状态寄存器（6）。</p>
<p>未分组寄存器（R0<del>R7）和分组寄存器（R8</del>R14）。程序计数器PC（R15）。程序状态寄存器CPSR（R16）。（中断禁止位、T标志位（Thumb）和工作模式位）</p>
<p>其中，Thumb只用到了R0~R7、R13和R14。</p>
<p><strong>异常：</strong></p>
<p>复位、未定义指令异常、软件中断异常、指令预取中止、数据中止、IRQ和FIQ（中断）。异常向量是异常服务程序的入口。</p>
<p><strong>存储器：</strong></p>
<p>支持大端存储和小端存储。ARM默认为<strong>小端存储</strong>格式。可以通过硬件输入<strong>引脚或配置字</strong>来配置。对存储单元的访问需要适当地对齐。使用存储器映射方式实现I/O端口地访问（因此<strong>没有in/out指令</strong>，统一指令实现）。</p>
<h3 id="2-ARM-存储器"><a href="#2-ARM-存储器" class="headerlink" title="2. ARM 存储器"></a>2. ARM 存储器</h3><p><strong>存储器分类：</strong></p>
<ul>
<li>主存储器：内存。只读存储器（ROM）、随机存储器（RAM）。</li>
<li>辅存储器：外设。硬盘。</li>
</ul>
<p>访问速度：寄存器&gt;cache&gt;SRAM&gt;DRAM&gt;ROM</p>
<p>辅助存储器：Flash技术。CF卡、SD卡。</p>
<p><strong>NAND Flash：</strong>以<strong>页</strong>为单位读和编程操作和以<strong>块</strong>为单位进行擦除。</p>
<p>K8F1208芯片：4096个Block，每个Block有32个Page，每个Page有528字节，512字节存储+16字节<strong>校验位</strong>。因此，对NAND Flash操作的地址分为3部分：块地址、页地址和页内地址。</p>
<p><strong>存储系统机制：</strong></p>
<p><strong>存储管理单元（MMU）：</strong>主要用来完成虚实地址和物理地址之间的转换。访问权限控制。MMU管理方式：<strong>段式、页式和段页式</strong>。</p>
<h3 id="3-ARM-时钟及电源管理"><a href="#3-ARM-时钟及电源管理" class="headerlink" title="3. ARM 时钟及电源管理"></a>3. ARM 时钟及电源管理</h3><p><strong>S3C2410时钟结构：</strong></p>
<p>不同总线对应有不同时钟。提供给<strong>CPU</strong>的<strong>FCLK</strong>、提供给<strong>AHB</strong>总线设备的<strong>HCLK</strong>和提供给<strong>APB</strong>总线设备的<strong>PCLK</strong>。</p>
<p><strong>2个锁相环（PLLs）：</strong>外部输入低频，利用闭环倍频。<strong>低频比较精准</strong>，高频不够精准。软件可以控制是否提供锁相环给某个设备，<strong>可以关闭锁相环</strong>，从而分级控制，降低功耗，规避干扰。1个是提供<strong>总线时钟</strong>，1个是提供<strong>USB时钟</strong>。</p>
<p><strong>S3C2410电源管理模式：</strong></p>
<p>电源管理模式（<strong>模式管理</strong>）：</p>
<ul>
<li>空闲模式（停止供给CPU核时钟）</li>
<li>正常模式（可软件控制）</li>
<li>低速模式（无PLL模式）</li>
<li>休眠/掉电模式（外部中断EINT[15:0]或RTC报警，唤醒逻辑独立供电）</li>
</ul>
<p>内核提供1.8V电压，处理器端口和存储端口提供3.3V电压。休眠模式也有1.8V。内部设备用电的电压一致，实际用电有<strong>上电延时</strong>，确保不同引脚都上电后，才进行初始化、配置和运行。</p>
<p>PS：主要思想是<strong>硬件</strong>上尽可能实现<strong>灵活性</strong>，<strong>软件</strong>工具包实现<strong>易用性</strong>。将复杂的更高层次的开发发展为软件的开发和移植。</p>
<h3 id="4-ARM-定时技术"><a href="#4-ARM-定时技术" class="headerlink" title="4. ARM 定时技术"></a>4. ARM 定时技术</h3><p>定时器是嵌入式系统重要的部件。</p>
<p>定时部件3类：看门狗、RTC部件和Timer部件。</p>
<ul>
<li><p>看门狗定时器：当程序“跑飞”时，恢复系统的运行，即监视并恢复程序正常运行。时钟（PCLK）。可能会有专用的内部振荡器。2个功能（定时器功能和复位功能）。组成部分（预分频器、再分频器、WTDAT数据寄存器、WTCNT计数器、WTCON控制寄存器和复位信号发生器）。先赋值，再启动。</p>
</li>
<li><p>RTC部件：实时时钟，软件编程支持。有的有独立时钟，有的有独立电源。存在数据失联问题（例如，读时间时，高位年月或日改变，导致数据错误实联），因此数据需要多次读确保数据不失联。报警功能可以提供闹钟功能。<strong>时钟精度要求高</strong>。</p>
</li>
<li><p>Timer部件：主要是脉宽调制（PWM）。任何模拟信号都可以使用PWM来实现，数字信号生成模拟信号。具有<strong>死区管理</strong>的功能。Timer0可以用于控制大功率设备。支持DMA的请求模式。DMA和CPU共同使用时，都需要控制总线，因此DMA的加入一定会影响CPU的总线执行的时序。如果需要精确的软件延时（循环实现），又要使用DMA，则计时会不准确。</p>
</li>
</ul>
<h3 id="5-ARM-中断"><a href="#5-ARM-中断" class="headerlink" title="5. ARM 中断"></a>5. ARM 中断</h3><p>对于设备的访问有：程序查询方式（效率比较低）、中断方式和DMA方式。</p>
<p><strong>特点：</strong>（1）<strong>实时</strong>性能好（2）调试较复杂（中断嵌套）</p>
<p>可以处理难以预料的故障。</p>
<p><strong>DMA方式与中断方式相比：</strong></p>
<ul>
<li>中断方式，MPU需要执行多条指令，占用一定的时间；DMA 传送1字节只占用1个总线周期，占用MPU时间少。</li>
<li>DMA的响应速度比中断快。中断需要执行完当前指令并保护现场，而DMA请求在总线周期执行完就可响应。</li>
<li>对于快速的I/O设备，中断无法满足要求，必须采用DMA的方式。</li>
</ul>
<p><strong>中断向量：</strong></p>
<p>ARM可以由软件配置使用独立中断向量或可变中断向量设计。可进行中断向量的分组。</p>
<p><strong>中断类别：</strong></p>
<p>中断主要分为普通中断（IRQ）和快速（异常）中断（FIQ）。</p>
<p><strong>中断管理：</strong></p>
<p>主要通过模式、屏蔽、优先级和挂起（标志）来实现。快速中断没有优先级的判断。</p>
<p>ARM拥有<strong>独立的</strong>中断向量和<strong>分组的</strong>中断向量（根据优先级）。</p>
<p>FIQ<strong>快速异常中断</strong>的执行优先级更高。</p>
<h3 id="6-ARM-DMA"><a href="#6-ARM-DMA" class="headerlink" title="6. ARM DMA"></a>6. ARM DMA</h3><p><strong>定义：</strong><br>DMA技术是一种高速的数据传输方式，允许在外部设备和存储器之间、存储器与存储器之间等直接传输数据。</p>
<p><strong>哪些部件可以作为源与目的的？</strong></p>
<p><strong>外部DMA请求：</strong></p>
<ul>
<li>单服务请求（突发单字节的传输）</li>
<li>单服务握手</li>
<li>全服务握手</li>
</ul>
<p><strong>DMA的知识点：</strong></p>
<ul>
<li><p>优先级</p>
</li>
<li><p>源和目的之间的关系</p>
</li>
<li><p>是否支持高速的传递</p>
</li>
<li><p>是否支持批量的传递</p>
</li>
<li><p>是否支持突发单数据传递</p>
</li>
<li><p>生成数据和数据传输完毕后，能不能产生DMA的中断</p>
</li>
<li><p><strong>DMA的使用会影响CPU的时间</strong></p>
</li>
</ul>
]]></content>
      <categories>
        <category>嵌入式系统安全</category>
      </categories>
      <tags>
        <tag>嵌入式系统安全</tag>
        <tag>ARM</tag>
        <tag>PIC</tag>
      </tags>
  </entry>
  <entry>
    <title>网络侦察实验</title>
    <url>/2020/03/16/%E7%BD%91%E7%BB%9C%E4%BE%A6%E5%AF%9F%E5%AE%9E%E9%AA%8C/</url>
    <content><![CDATA[<h2 id="任务四-获取目标网站的webshell权限，控制目标机，获得敏感信息"><a href="#任务四-获取目标网站的webshell权限，控制目标机，获得敏感信息" class="headerlink" title="任务四 获取目标网站的webshell权限，控制目标机，获得敏感信息"></a>任务四 获取目标网站的webshell权限，控制目标机，获得敏感信息</h2><h3 id="1-准备工作"><a href="#1-准备工作" class="headerlink" title="1. 准备工作"></a>1. 准备工作</h3><p>Linux指令：从命令行界面进入图形界面（下面两个指令都可）</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ startx </span><br><span class="line">$ init 5</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<p>Linux指令：从图形界面进入命令行界面</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ init 3</span><br></pre></td></tr></table></figure>

<p>PS：实际操作中，在远程的网络安全实验平台上，使用startx一切正常，但是使用另外2条指令会出现问题。先留个坑~。</p>
<h3 id="2-创建HTML文件上传表单"><a href="#2-创建HTML文件上传表单" class="headerlink" title="2. 创建HTML文件上传表单"></a>2. 创建HTML文件上传表单</h3><p>基本知识：</p>
<p>（1） 必需的 action 属性规定当提交表单时，向何处发送表单数据。 </p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"value"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>（2） enctype 属性规定在发送到服务器之前应该如何对表单数据进行编码。  在使用包含文件上传控件的表单时，必须使用 multipart/form-data 。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">enctype</span>=<span class="string">"value"</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>创建一个上传表单的简单HTML文件。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">"对应提交网址处"</span> <span class="attr">method</span>=<span class="string">"post"</span> <span class="attr">enctype</span>=<span class="string">"multipart/form-data"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">label</span> <span class="attr">for</span>=<span class="string">"file"</span>&gt;</span>filename: <span class="tag">&lt;/<span class="name">label</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"file"</span> <span class="attr">name</span>=<span class="string">"attach"</span> <span class="attr">id</span>=<span class="string">"file"</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"submit"</span> <span class="attr">name</span>=<span class="string">"submit"</span> <span class="attr">value</span>=<span class="string">"submit"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br><span class="line">   <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
      </tags>
  </entry>
  <entry>
    <title>网络安全笔记_DDoS攻击</title>
    <url>/2020/03/16/%E7%BD%91%E7%BB%9C%E5%AE%89%E5%85%A8%E7%AC%94%E8%AE%B0_DDoS%E6%94%BB%E5%87%BB/</url>
    <content><![CDATA[<h2 id="网络侦察"><a href="#网络侦察" class="headerlink" title="网络侦察"></a>网络侦察</h2><h3 id="交换式网络环境的监听："><a href="#交换式网络环境的监听：" class="headerlink" title="交换式网络环境的监听："></a>交换式网络环境的监听：</h3><p>（1）ARP欺骗（<strong>ARP spoofing</strong>）：网关的MAC和IP地址与自己的地址绑定。</p>
<p>（2）在交换机上做端口镜像，把交换机上的数据拷贝到其他端口上。</p>
<a id="more"></a>

<h3 id="口令猜测："><a href="#口令猜测：" class="headerlink" title="口令猜测："></a>口令猜测：</h3><p>（1）字典攻击。（2）基于概率的口令猜测。概率大小决定测试先后次序。</p>
<h2 id="拒绝服务攻击DoS（Denial-of-Service）"><a href="#拒绝服务攻击DoS（Denial-of-Service）" class="headerlink" title="拒绝服务攻击DoS（Denial of Service）"></a>拒绝服务攻击DoS（Denial of Service）</h2><h3 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h3><p>阻止或拒绝合法使用者存取网络服务器。</p>
<h3 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h3><p>往往是针对TCP/IP协议中的某个弱点。从某种程度上，DoS攻击永远不会消失。（资源有限，但访问存取是无限的，跟承载能力有关）从技术上，没有根本的解决办法。一个解决思路：网络基础设施上溯源。</p>
<h3 id="攻击模式："><a href="#攻击模式：" class="headerlink" title="攻击模式："></a>攻击模式：</h3><p>（1）消耗资源：针对流量的攻击、消耗磁盘空间、消耗CPU（CPU 多核 开多线程 跑死循环）和内存资源（申请内存 malloc new 递归）。未及时free易造成内存泄露的问题。</p>
<p>PS：<strong>内存泄漏（Memory Leak）：</strong>指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>
<p>（2）破坏或更改配置信息。</p>
<p>（3）物理破坏或改变网络部件。防御：加强管理。</p>
<h3 id="常见DoS攻击："><a href="#常见DoS攻击：" class="headerlink" title="常见DoS攻击："></a>常见DoS攻击：</h3><p><strong>SYN Flooding：</strong></p>
<p>利用TCP连接的常见服务端口攻击。</p>
<p>表现：短时间大量SYN包。</p>
<p>TCP连接的三次握手，存储接收到的数据，进行缓存，缓存充满使服务终止。连接请求超过超时的处理，即可最终充满。客户端利用假IP，不发送第三次响应包。</p>
<p>特点：</p>
<ul>
<li>利用TCP/IP协议的薄弱环节进行攻击</li>
<li>利用较少数据流量就可</li>
<li>攻击来源无法定位</li>
<li>在服务端无法区分TCP连接请求的合法性.</li>
</ul>
<p>应对：（1）优化系统配置（缓冲区扩大和超时时间减小）（2）优化路由器配置</p>
<p><strong>Smurf攻击：</strong></p>
<p>结合使用IP欺骗和ICMP回复的攻击。</p>
<p><strong>Ping of Death攻击</strong></p>
<p><strong>Teardrop攻击</strong></p>
<p><strong>Land攻击：</strong>设置IP为127.0.0.1，向自己发响应包。</p>
<p><strong>电子邮件轰炸</strong>：SMTP端口（25）：早期未授权访问，发送地址可以自己设定。</p>
<p>目前为ESMTP服务。hello过程之后，会有自己邮件地址和口令的认证。</p>
<p>应对：配置路由器和防火墙，识别源头。</p>
<h3 id="分布式拒绝服务攻击DDoS："><a href="#分布式拒绝服务攻击DDoS：" class="headerlink" title="分布式拒绝服务攻击DDoS："></a>分布式拒绝服务攻击DDoS：</h3><p>相比传统的DoS攻击：（1）网络资源的限制减小（2）隐蔽性高</p>
<p>DDoS的三级控制结构。客户端（Client）、中间机（Handler）和代理机（Agent）。</p>
<p>应对：</p>
<ul>
<li>在数据流中搜寻特征字符串</li>
<li>利用数据包的某些特征</li>
<li>监视本地主机端口的使用</li>
<li>对通信数据量进行统计</li>
</ul>
<h2 id="缓冲区溢出攻击"><a href="#缓冲区溢出攻击" class="headerlink" title="缓冲区溢出攻击"></a>缓冲区溢出攻击</h2><h3 id="缓冲区定义："><a href="#缓冲区定义：" class="headerlink" title="缓冲区定义："></a>缓冲区定义：</h3><p>一段连续的存储空间。（堆或栈的空间）</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> i;</span><br></pre></td></tr></table></figure>

<p>三重含义：（1）在内存存储创建的位置（2）存储空间大小（3）数据存储格式。例如int与double不同。</p>
<h3 id="缓冲区溢出定义："><a href="#缓冲区溢出定义：" class="headerlink" title="缓冲区溢出定义："></a>缓冲区溢出定义：</h3><p>指写入缓冲区的数据量超过了该缓冲区的最大限度，造成溢出数据改写了缓冲区相邻的原始数据。</p>
<h3 id="缓冲区溢出危害："><a href="#缓冲区溢出危害：" class="headerlink" title="缓冲区溢出危害："></a>缓冲区溢出危害：</h3><ul>
<li>实现任意执行代码</li>
<li>进行DoS攻击</li>
<li>破坏关键数据，使系统的稳定性和有效性受到影响</li>
<li>进行蠕虫攻击 Morris</li>
</ul>
<h3 id="缓冲区溢出的根本原因："><a href="#缓冲区溢出的根本原因：" class="headerlink" title="缓冲区溢出的根本原因："></a>缓冲区溢出的根本原因：</h3><p>代码操作缓冲区时，没有对缓冲区边界检查，导致溢出数据改写缓冲区相邻单元的数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>((*d++=*s++)!=<span class="string">'\0'</span>);      <span class="comment">//strcpy函数实现</span></span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>网络安全</tag>
        <tag>DoS</tag>
        <tag>缓冲区溢出</tag>
      </tags>
  </entry>
  <entry>
    <title>Orange&#39;s 一个操作系统实现 小知识点</title>
    <url>/2020/03/15/Orange&#39;s%20%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%20%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/</url>
    <content><![CDATA[<h3 id="一些小知识点"><a href="#一些小知识点" class="headerlink" title="一些小知识点"></a>一些小知识点</h3><ul>
<li><p>CPU发展</p>
<p><strong>8086</strong> 16位 CPU =&gt; <strong>80386</strong> 32位 CPU</p>
</li>
<li><p>实模式&amp;保护模式</p>
<table>
<thead>
<tr>
<th align="center">模式</th>
<th align="center">进制数</th>
<th align="center">地址总线宽度</th>
<th align="center">寄存器及数据总线宽度</th>
<th align="center">寻址空间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">实模式</td>
<td align="center">16</td>
<td align="center">20</td>
<td align="center">16</td>
<td align="center">1MB</td>
</tr>
<tr>
<td align="center">保护模式</td>
<td align="center">32</td>
<td align="center">32</td>
<td align="center">32</td>
<td align="center">4GB</td>
</tr>
</tbody></table>
</li>
</ul>
<a id="more"></a>

<ul>
<li><p>段寄存器</p>
<p>32位段寄存器实际上由16位的段选择器和描述符高速缓存器组成。但描述符高速缓存器是不能直接访问的。</p>
</li>
<li><p>代码段和数据段的权限访问规则</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">特权级 低-&gt;高</th>
<th align="center">特权级 高-&gt;低</th>
<th align="center">相同特权级之间</th>
</tr>
</thead>
<tbody><tr>
<td align="center">一致代码段</td>
<td align="center">可</td>
<td align="center">不可</td>
<td align="center">可</td>
</tr>
<tr>
<td align="center">非一致代码段</td>
<td align="center">不可</td>
<td align="center">不可</td>
<td align="center">可</td>
</tr>
<tr>
<td align="center">数据段（非一致）</td>
<td align="center">不可</td>
<td align="center">可</td>
<td align="center">可</td>
</tr>
</tbody></table>
</li>
<li><p><strong>汇编语言</strong>里的一些<strong>寄存器</strong>的功能：</p>
<p><strong>EAX</strong> 是”累加器”(accumulator), 它是很多加法乘法指令的缺省寄存器。</p>
<p><strong>EBX</strong> 是”基地址”(base)寄存器, 在内存寻址时存放基地址。</p>
<p><strong>ECX</strong> 是计数器(counter), 是重复(REP)前缀指令和LOOP指令的内定计数器。</p>
<p><strong>EDX</strong> 则总是被用来放整数除法产生的余数。</p>
<p><strong>ESI/EDI</strong>分别叫做”源/目标索引寄存器”(source/destination index),因为在很多字符串操作指令中, DS:ESI指向源串,而ES:EDI指向目标串。</p>
<p><strong>EBP</strong>是”基址指针”(BASE POINTER), 它最经常被用作高级语言函数调用的”框架指针”(frame pointer)。</p>
<p><strong>ESP</strong> 专门用作堆栈指针，被形象地称为栈顶指针，堆栈的顶部是地址小的区域，压入堆栈的数据越多，ESP也就越来越小。在32位平台上，ESP每次减少4字节。</p>
</li>
<li><p><strong>寄存器EAX、AX、AH和AL之间的关系：</strong></p>
<p>EAX 为32位。</p>
<p>AX为EAX低16位。</p>
<p>AH为AX高8位，AL为AX低8位。</p>
</li>
<li><p><strong>dd、dw和db：</strong></p>
<p>汇编语言中dd、dw和db分别代表4个字节、2个字节和1个字节。</p>
</li>
<li><p><strong>汇编指令JC：</strong></p>
<p>汇编指令，当进位标志CF=1，即有进位时，跳转。</p>
</li>
<li><p><strong>标志位寄存器：</strong></p>
<p><img src="/2020/03/15/Orange's%20%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%20%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/2.png" alt="2"></p>
</li>
<li><p><strong>汇编指令cmp：</strong></p>
<p>cmp指令格式:  cmp  操作对象1, 操作对象2</p>
<p>计算（操作对象1 - 操作对象2），但不保存结果，只是根据结果修改相应的标志位。 </p>
</li>
<li><p><strong>汇编指令jne：</strong></p>
<p>jne是汇编指令中的一个条件转移指令。当ZF=0，转至标号处执行。当ZF=1，顺序执行。</p>
</li>
<li><p><strong>地址描述符结构ARDS：</strong></p>
<table>
<thead>
<tr>
<th><strong>Offset</strong></th>
<th><strong>Name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>BaseAddrLow</td>
<td>基地址的低32位</td>
</tr>
<tr>
<td>4</td>
<td>BaseAddrHigh</td>
<td>基地址的高32位</td>
</tr>
<tr>
<td>8</td>
<td>LengthLow</td>
<td>长度(字节)的低32位</td>
</tr>
<tr>
<td>12</td>
<td>LengthHigh</td>
<td>长度(字节)的高32位</td>
</tr>
<tr>
<td>16</td>
<td>Type</td>
<td>这个地址范围的地址类型</td>
</tr>
</tbody></table>
<p><strong>Type取值及其意义：</strong></p>
<table>
<thead>
<tr>
<th><strong>Value</strong></th>
<th><strong>Name</strong></th>
<th><strong>Description</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>AddressRangeMemory</td>
<td>这个内存段是一段可以被OS使用的RAM</td>
</tr>
<tr>
<td>2</td>
<td>AddressRangeReserved</td>
<td>这个地址段正在被使用,或者被系统保留,所以一定不要被OS使用</td>
</tr>
<tr>
<td>Other</td>
<td>Undefined</td>
<td>保留为未来使用,任何其它值都必需被OS认为是AddressRangeReserved</td>
</tr>
</tbody></table>
</li>
<li><p><strong>汇编指令inc&amp;dec：</strong></p>
<p>自加1和自减1指令。</p>
</li>
<li><p><strong>汇编指令ja&amp;jb：</strong></p>
<p>指令JA表示 CF=0 且ZF=0 即A&gt;B转移。</p>
<p>指令JB表示 CF=1 且ZF=0 即A &lt;B转移。</p>
</li>
<li><p><strong>汇编指令跳转部分：</strong></p>
<p>JAE/JNB 大于或等于转移.<br>JB/JNAE 小于转移.<br>JBE/JNA 小于或等于转移.<br>以上四条,测试<strong>无符号整数运算</strong>的结果(<strong>标志C和Z</strong>).<br>JE/JZ　等于转移.<br>JNE/JNZ 不等于时转移.<br>JC　　　有进位（CF）时转移.<br>JNC　　无进位（CF）时转移.<br>JNO　　不溢出时转移.<br>JNP/JPO 奇偶性为奇数时转移.<br>JNS　　符号位为 “0” 时转移.<br>JO　　　溢出转移.<br>JP/JPE　奇偶性为偶数时转移.<br>JS　　　符号位为 “1” 时转移.</p>
</li>
<li><p>保护模式不能直接调用实模式下的中断</p>
</li>
<li><p>硬件中断与软件中断</p>
</li>
<li><p>同步中断（与CPU相关）与异步中断（外部不可抗因素）</p>
</li>
<li><p>Fault（如缺页） Trap（） Abort（严重错误）</p>
</li>
<li><p>IDT建立保护模式下的中断（GDT保护模式下段机制）</p>
</li>
<li><p>中断和异常分配表</p>
<p><img src="/2020/03/15/Orange's%20%E4%B8%80%E4%B8%AA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%AE%9E%E7%8E%B0%20%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9/1.PNG" alt="1"></p>
</li>
<li><p><strong>bochs调试反汇编指令：</strong></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ndisasm -o 0x7c00 boot.bin &gt;&gt; disboot.asm</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>在bochs的dos下调试：</strong></p>
<p>先在文件开始位置添加指令jmp $，然后在反汇编的文件中找到自己想要跳转的位置eip。然后在bochs的dos中运行，陷入死循环。在bochs中，利用ctrl+c中断调试，利用r看寄存器的值，利用set $eip=0x…值，利用s进行单步调试。</p>
</li>
<li><p><strong>lodsb指令：</strong></p>
<p>LODSB/LODSW/LODSD</p>
<p>功能：将DS：SI/ESI所指的源串元素装入累加器(AL，AX，EAX)中，每装入一次都按照DF值以及串元素类型自动修改地址指针SI/ESI，该指令一般不须加重复前缀，并且不影响标志位。</p>
</li>
<li><p><strong>Bochs命令：</strong></p>
<p>挂载：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo mount -o loop a.img /mnt/floppy/</span><br><span class="line">sudo cp kernel.bin /mnt/floppy/</span><br><span class="line">sudo umount /mnt/floppy/</span><br></pre></td></tr></table></figure>

<p>copy：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp /home/username/桌面/boot.asm ./</span><br></pre></td></tr></table></figure>

<p>更新引导程序：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">dd <span class="keyword">if</span>=boot.bin of=a.img bs=512 count=1 conv=notrunc</span><br></pre></td></tr></table></figure>

<p>运行Bochs：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">bochs -f bochsrc</span><br></pre></td></tr></table></figure>

<p>nasm编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nasm loader.asm -o loader.bin</span><br><span class="line"></span><br><span class="line">nasm -f elf kliba.asm -o kliba.o</span><br></pre></td></tr></table></figure>

<p>gcc编译：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c start.c -o start.o</span><br></pre></td></tr></table></figure>

<p>ld链接：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ld -s -Ttext 0x30400 -o kernel.bin kernel.o string.o start.o</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>关于GPU服务器的一点小经验</title>
    <url>/2020/03/15/%E5%85%B3%E4%BA%8EGPU%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84%E4%B8%80%E7%82%B9%E5%B0%8F%E7%BB%8F%E9%AA%8C/</url>
    <content><![CDATA[<p><strong>主要目的：</strong>跑一些深度学习的代码，但是自己笔记本显卡内存比较小，运行速度也比较慢。</p>
<p>下面介绍一下对几个使用过的云GPU服务器的看法：</p>
<a id="more"></a>

<p>PS：使用<strong>专业版</strong>Pycharm，可以远程调用GPU云服务器来运行程序，但<strong>家庭版</strong>Pycharm则不具备该功能。</p>
<ul>
<li><p><strong>腾讯云：</strong>最一开始使用的是腾讯云。因为感觉大厂有保障，的确还不错但就是价格较高，服务器价格比其他网站贵了很多。有云端对象存储COS，1RMB=6个月50G的空间（利用代码可以实现云端上传/下载，速度较快，比家里的垃圾网速强好多）。感觉还不错。</p>
<p>网址：<a href="https://cloud.tencent.com/" target="_blank" rel="noopener"><strong>腾讯云</strong></a></p>
</li>
<li><p><strong>MistGPU：</strong>新用户有8RMB的代金券。价格较低。1080ti=3RMB/小时。2080ti=4RMB/小时。但上传速度慢（可以使用腾讯云对象存储的数据集，写一个python脚本，实现云端下载，速度飞快，比家里的垃圾网速强好多）。PS：IP地址显示为阿里云。</p>
<p>网址：<a href="https://mistgpu.cn/" target="_blank" rel="noopener"><strong>MistGPU</strong></a></p>
</li>
<li><p><strong>Colab：</strong>Google旗下的一个Jupyter笔记本的运行环境。不需要任何设置就可以直接使用，完全在云端运行。薅资本主义的羊毛。GPU也由之前的K80更换为了T4（其实感觉免费的没有达到T4）。但需要科学上网来使用Google Drive。另外，Google Drive的大文件的上传速度惊人的慢（大于1G的文件），也许是因为需要科学上网的缘故。运行一些小型的训练模型没问题，但大型的训练模型则需要最好使用Colab Pro，$9.99/月。订阅后可以获得T4和P100 GPU计算资源，还可能优先分配到TPU。但需要美国的信用卡美元订阅支付。</p>
<p>网址：<a href="https://colab.research.google.com/notebooks/intro.ipynb" target="_blank" rel="noopener"><strong>Colab</strong></a></p>
</li>
</ul>
<p>用到现在，感觉最佳组合是腾讯云对象存储（最近搞活动，1RMB=6个月50G的空间，感觉超值，也有免费的空间）+ MistGPU。价格可以接受，配置也比较不错。另外，淘宝上也有相关的GPU包天的服务，感觉蛮麻烦的就没有试。</p>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>云服务器</tag>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2020/03/15/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Hexo的4个常用命令："><a href="#Hexo的4个常用命令：" class="headerlink" title="Hexo的4个常用命令："></a>Hexo的4个常用命令：</h3><a id="more"></a>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo g  <span class="comment">#generate 生成静态文件。</span></span><br><span class="line">$ hexo s  <span class="comment">#server 启动服务器。可本地预览。</span></span><br><span class="line">$ hexo d  <span class="comment">#deploy 部署网站同步到github。</span></span><br><span class="line">$ hexo clean  <span class="comment">#clean 清除缓存文件 (db.json) 和已生成的静态文件 (public)。</span></span><br></pre></td></tr></table></figure>
<p>详细信息：<a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a>、<a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a>和<a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>
<h3 id="本地预览的默认本地地址"><a href="#本地预览的默认本地地址" class="headerlink" title="本地预览的默认本地地址"></a>本地预览的默认本地地址</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">http:&#x2F;&#x2F;localhost:4000&#x2F;</span><br></pre></td></tr></table></figure>
<h3 id="写文章"><a href="#写文章" class="headerlink" title="写文章"></a>写文章</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new [layout] &lt;title&gt; <span class="comment"># 新建文章</span></span><br></pre></td></tr></table></figure>

<p>详细信息：<a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p>
<h3 id="一般修改后重新运行"><a href="#一般修改后重新运行" class="headerlink" title="一般修改后重新运行"></a>一般修改后重新运行</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean</span><br><span class="line">$ hexo g -d</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
</search>
